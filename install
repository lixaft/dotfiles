#!/usr/bin/env python3
from __future__ import annotations

import argparse
import os
import shutil
import subprocess
from typing import Any
from typing import Callable
from typing import Iterable
from typing import NamedTuple
from typing import Sequence


class File(NamedTuple):
    source: str
    destination: str


class Repository(NamedTuple):
    url: str
    path: str


def here(path: str) -> str:
    return os.path.abspath(os.path.join(os.path.dirname(__file__), path))


def home(path: str) -> str:
    return os.path.abspath(os.path.expanduser(os.path.join("~", path)))


FILES: list[File] = [
    File(here("src/.bashrc"), home(".bashrc")),
    File(here("src/.config/bat"), home(".config/bat")),
    File(here("src/.config/fish"), home(".config/fish")),
    File(here("src/.config/nvim"), home(".config/nvim")),
    File(here("src/.config/starship.toml"), home(".config/starship.toml")),
    File(here("src/.gitconfig"), home(".gitconfig")),
    File(here("src/.pdbrc"), home(".pdbrc")),
    File(here("src/.pythonrc"), home(".pythonrc")),
    File(here("src/.tmux.conf"), home(".tmux.conf")),
    File(here("src/.vim"), home(".vim")),
    File(here("src/.vimrc"), home(".vimrc")),
]


REPOSITORIES: list[Repository] = [
    Repository(
        "https://github.com/tmux-plugins/tpm",
        home(".tmux/plugins/tpm"),
    ),
    Repository(
        "https://github.com/wbthomason/packer.nvim",
        home(".local/share/nvim/site/pack/packer/start/packer.nvim"),
    ),
]


def _delete(path: str) -> None:
    if os.path.islink(path):
        os.unlink(path)
    elif os.path.isdir(path):
        shutil.rmtree(path)
    else:
        os.remove(path)


def symlink_file(file: File, force: bool = False) -> int:
    if os.path.exists(file.destination):
        if os.path.samefile(file.source, file.destination):
            return 0
        if not force:
            return 1
        _delete(file.destination)

    directory = os.path.dirname(file.destination)
    if not os.path.exists(directory):
        os.makedirs(directory)
    os.symlink(
        file.source,
        file.destination,
        target_is_directory=os.path.isdir(file.source),
    )
    return 0


def clone_repository(repository: Repository, force: bool = False) -> int:
    if os.path.exists(repository.path):
        if not force:
            return 1
        _delete(repository.path)

    try:
        subprocess.check_call(
            ("git", "clone", repository.url, repository.path),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
    except subprocess.CalledProcessError as e:
        return e.returncode
    return 0


NORMAL = "\033[m"
BOLD = f"{NORMAL}\033[1m"
GRAY = f"{NORMAL}\033[2m"
RED = f"{NORMAL}\033[31;1m"
GREEN = f"{NORMAL}\033[32;1m"
BLUE = f"{NORMAL}\033[34;1m"


class Step(NamedTuple):
    name: str
    func: Callable[..., int]
    args: list[Any]
    kwargs: dict[str, Any]


class _TaskResult:
    def __init__(self) -> None:
        self.ok: list[Step] = []
        self.fail: list[Step] = []


class Runner:

    def __init__(self) -> None:
        self._results: dict[str, _TaskResult] = {}
        self._global_ok = True

    def run_task(self, name: str, steps: Iterable[Step]) -> None:
        print(f"{BLUE}~~> {BOLD}{name}...{NORMAL}", flush=True)
        result = _TaskResult()
        for step in steps:
            ret = step.func(*step.args, **step.kwargs)

            if ret:
                result.fail.append(step)
                color = RED
                text = "FAIL"
                self._global_ok = False
            else:
                result.ok.append(step)
                color = GREEN
                text = "OK"

            print(f"[{color}{text}{NORMAL}] {step.name}", flush=True)

        self._results[name] = result
        print("", flush=True)

    def summary(self) -> None:
        line = " Summary ".center(shutil.get_terminal_size().columns, "â”€")
        print(
            f"{GREEN if {self._global_ok} else RED}{line}{NORMAL}",
            flush=True,
        )

        for task, result in self._results.items():
            print(
                f"[{task}]: "
                f"{GREEN}{len(result.ok)}{NORMAL} ok, "
                f"{RED}{len(result.fail)}{NORMAL} fail",
                flush=True,
            )
            for step in result.fail:
                print(f"\t{GRAY}{step.name}{NORMAL}", flush=True)


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--force", "-f", action="store_true")
    args = parser.parse_args(argv)

    runner = Runner()

    symlink_steps: list[Step] = []
    for file in FILES:
        step = Step(
            os.path.relpath(file.source, start=here("src")),
            symlink_file,
            [file],
            {"force": args.force},
        )
        symlink_steps.append(step)
    runner.run_task("Symlink", symlink_steps)

    clone_steps: list[Step] = []
    for repo in REPOSITORIES:
        step = Step(
            repo.url,
            clone_repository,
            [repo],
            {"force": args.force},
        )
        clone_steps.append(step)
    runner.run_task("Clone", clone_steps)

    runner.summary()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
